<!DOCTYPE HTML PUBLIC '-//W3C//DTD HTML 4.01 Transitional//EN'>
<html>
<head>
<title>Benchmarking Go and Python Web servers</title>
<meta http-equiv='Content-type' content='text/html; charset=utf-8'>
<style type='text/css' media='all'>
body {
  font-family: "Bitstream Vera Sans", Verdana, sans-serif;
  font-size: 13px;
  line-height: 1.23em;
  padding: 0;
  margin: 1.23em;
  background: white;
  color: black;
}
em {
  font-style: italic;
  color: #034;
}
a {
  color: #04a;
  text-decoration: none;
  font-style: italic;
}
a:hover {
  color: #a40;
  text-decoration: underline;
}
a:active {
  color: #c00;
}
code, pre {
  font-size: 13px; 
}
pre {
  background: #F0F0F0;
  padding: 0.5em 2em;
}
table {
  background: #fff;
  border-collapse: collapse;
  margin: 2px;
  font-family: sans-serif;
  font-size: 12px;
}
th {
    background:	#a64;
    color: #fff;
    padding: 2px;
    border: 1px solid #ba9;
}
td {
    text-align: center;
    padding: 2px;
    border: 1px solid #ba9;
}
td:last-child {
    text-align: left;
}
td div {
    height: 10px;
}
</style>
</head>
<body>
<h2>Benchmarking Go and Python Web servers</h2>

<p>To build the Web applications I use mostly
<a href='http://www.python.org/'>Python</a>. An year ago I started
learning <a href='http://golang.org/'>Go</a>, mainly for fun. In the meantime it
turned out that I have to rewrite some old CGI application written in C, which
have worked with <a href='http://www.acme.com/software/thttpd/'>thttpd</a>
server in <a href='http://en.wikipedia.org/wiki/Chroot'>chroot</a> mode. I
started searching for a tool with which I could write a standalone web
application with embedded web server, easy to chroot. At the same time I started
play with <a href='http://www.getwebgo.com'>web.go</a> framework,
<a href='https://github.com/hoisie/mustache.go'>mustache.go</a>
templates, Go native <a href='http://golang.org/pkg/http/'>http</a> package and
<a href='https://github.com/Philio/GoMySQL'>GoMySQL</a> database API. I found
that the Go with <em>http</em>, <em>mustache.go</em> and <em>GoMySQL</em>
packages would be an ideal tools to do my job. So I decided to try write my
application in Go.</p>

<p>During work it appeared that I need something more flexible than
<em>mustache.go</em> and something more mature and bug-free than
<em>GoMySQL</em>. Finally, I wrote my application using
<a href='https://github.com/ziutek/kasia.go'>Kasia.go</a> templates and 
<a href='https://github.com/ziutek/mymysql'>MyMySQL</a> (I wrote these packages
specifically for my application but decided to make it available for Go
community). Rewritten application works very well in production, even under
much greater load than the previous one. I began to wonder about how faster
(or maybe slower) is Go than Python for implementing standalone Web
applications. I decided to do several tests, taking into account the use of
different frameworks and servers. For comparison, I picked up following Go
packages:</p>

<ul>
    <li>raw Go <em>http</em> package,</li>
    <li><em>web.go</em> framework (it uses <em>http</em> package to run in
    standalone mode),</li>
    <li><a href='http://garyburd.github.com/twister/'>twister</a> framework (it
    also uses <em>http</em> package),
</ul>

<p>and following Python Web servers/frameworks:</p>

<ul>
    <li><a href='http://webpy.org/'>web.py</a> framework with
    <a href='http://www.cherrypy.org'>CherryPy</a> WSGI server,</li>
    <li><em>web.py</em> framework with
    <a href='http://gunicorn.org/'>gunicorn</a> WSGI server,</li>
    <li><em>web.py</em> framework using
    <a href='http://trac.saddi.com/flup'>flup</a>
    <a href='http://en.wikipedia.org/wiki/FastCGI'>FastCGI</a> to be a
    backend process for <a href='http://wiki.nginx.org/Main'>nginx</a> server,
    </li>
    <li><a href='http://www.tornadoweb.org/'>tornado</a> asynchronous
    server/framework,</li>
    <li><em>tornado</em> with <em>nginx</em> as a load balancer.
</ul>

<p>For each case I wrote a simple application, slightly more complicated that
typical <em>Hello World</em> example. Any application consist of:</p>

<ul>
    <li>parsing parameters in URL path using regular expressions,</li>
    <li>using <em>for</em> statement to create multiple line output,</li>
    <li>using <em>printf</em>-like formatting function/expression to format
    output.<li>
</ul>

<p>I think that these operations are common in any Web application, so should be
included in any simple benchmark test. Below I put links to the source code for
all test applications:</p>

<ul>
<li>
<a href='https://github.com/ziutek/web_bench/blob/master/http.go'>Go http</a>
</li>
<li>
<a href='https://github.com/ziutek/web_bench/blob/master/webgo.go'>web.go</a>
</li>
<li>
<a href='https://github.com/ziutek/web_bench/blob/master/twister.go'>twister</a>
</li>
<li>
<a href='https://github.com/ziutek/web_bench/blob/master/webpy.py'>web.py</a>
</li>
<li>
<a href='https://github.com/ziutek/web_bench/blob/master/trnado.py'>tornado</a>
</li>
</ul>

<h3>Testing environment</h3>

<p>The test environment consisted of two PCs (traffic generator and application
server) connected using direct GigabitEthernet link.</p>

<ul>
    <li><em>Generator</em>: 2 x Xeon 2.6 GHz with hyperthreading, Debian SID,
    kernel: 2.6.33.7.2-rt30-1-686 #1 SMP PREEMPT RT;</li>
    <li><em>Server</em>: MSI Netbook with two core Intel U4100 1.30GHz, AC power
    connected, 64-bit Ubuntu 10.10, kernel: 2.6.35-25-generic #44-Ubuntu SMP,
    Python 2.6.6-2ubuntu2, web.py 0.34-2, flup 1.0.2-1, tornado 0.2-1, nginx
    0.7.67-3ubuntu1
    (<a
        href='https://github.com/ziutek/web_bench/blob/master/nginx.conf'>config</a>);
    </li>
</ul>

<p>To generate HTTP traffic and measure the performance of any test application
I used <a href='http://www.joedog.org/index/siege-home'>siege</a>
benchmarking utility. Siege can simulate multiple users using multiple threads.
I use the following command to generate traffic:</p>

<pre>siege -c 200 -t 20s http://SERVER_ADDR:8080/Hello/100</pre>

<p>or multiple such commands with properly reduced <em>-c</em> parameter (in
case when I run multiple Python applications simultaneously). It simulates
traffic generated by 200 users and works for 20s. With given URL Web
application produces 100 lines output for any request. Go applications was
compiled using Go release.2011-02-01.1</p>

<h3>Results</h3>

<p>GOMAXPROCS=1, one Python process:<p>

<table>
    <tr><th>Framework</th><th colspan='2'>Transaction rate [1/sec]</th></tr>
    <tr>
        <td>Go http</td><td>1350</td>
        <td><div style='background: #0b0; width: 135px'></div></td>
    </tr>
    <tr>
        <td>Twister</td><td>1324</td>
        <td><div style='background: #d00; width: 132px'></div></td>
    </tr>
    <tr>
        <td>Web.go</td><td>1141</td>
        <td><div style='background: #00e; width: 114px'></div></td>
    </tr>
    <tr>
        <td>Tornado</td><td>882</td>
        <td><div style='background: #ed0; width: 88px'></div></td>
    </tr>
    <tr>
        <td>Tornado+nginx</td><td>862</td>
        <td><div style='background: #dd0; width: 86px'></div></td>
    </tr>
    <tr>
        <td>Web.py+gunicorn</td><td>266</td>
        <td><div style='background: #0ca; width: 27px'></div></td>
    </tr>
    <tr>
        <td>Web.py+CheryPy</td><td>169</td>
        <td><div style='background: #0dc; width: 17px'></div></td>
    </tr>
    <tr>
        <td>Web.py+nginx</td><td>114</td>
        <td><div style='background: #0de; width: 11px'></div></td>
    </tr>
</table>

<p>GOMAXPROCS=2, two Python processes working simultaneously:</p>

<table>
    <tr><th>Framework</th><th colspan='2'>Transaction rate [1/sec]</th></tr>
    <tr>
        <td>Go http</td><td>1768</td>
        <td><div style='background: #0b0; width: 177px'></div></td>
    </tr>
    <tr>
        <td>Twister</td><td>1746</td>
        <td><div style='background: #d00; width: 175px'></div></td>
    </tr>
    <tr>
        <td>Tornado</td><td>1682</td>
        <td><div style='background: #ed0; width: 168px'></div></td>
    </tr>
    <tr>
        <td>Web.go</td><td>1516</td>
        <td><div style='background: #00e; width: 152px'></div></td>
    </tr>
    <tr>
        <td>Tornado+nginx</td><td>1378</td>
        <td><div style='background: #dd0; width: 138px'></div></td>
    </tr>
    <tr>
        <td>Web.py+gunicorn</td><td>406</td>
        <td><div style='background: #0ca; width: 41px'></div></td>
    </tr>
    <tr>
        <td>Web.py+CheryPy</td><td>308</td>
        <td><div style='background: #0dc; width: 31px'></div></td>
    </tr>
    <tr>
        <td>Web.py+nginx</td><td>198</td>
        <td><div style='background: #0de; width: 20px'></div></td>
    </tr>
</table>

<p>GOMAXPROCS=4, four Python processes working simultaneously:</p>

<table>
    <tr><th>Framework</th><th colspan='2'>Transaction rate [1/sec]</th></tr>
    <tr>
        <td>Go http</td><td>2063</td>
        <td><div style='background: #0b0; width: 206px'></div></td>
    </tr>
    <tr>
        <td>Twister</td><td>2020</td>
        <td><div style='background: #d00; width: 202px'></div></td>
    </tr>
    <tr>
        <td>Web.go</td><td>1753</td>
        <td><div style='background: #00e; width: 175px'></div></td>
    </tr>
    <tr>
        <td>Tornado</td><td>1662</td>
        <td><div style='background: #ed0; width: 166px'></div></td>
    </tr>
    <tr>
        <td>Tornado+nginx</td><td>1364</td>
        <td><div style='background: #dd0; width: 136px'></div></td>
    </tr>
    <tr>
        <td>Web.py+gunicorn</td><td>538</td>
        <td><div style='background: #0ca; width: 54px'></div></td>
    </tr>    
    <tr>
        <td>Web.py+CheryPy</td><td>304</td>
        <td><div style='background: #0dc; width: 30px'></div></td>
    </tr>
    <tr>
        <td>Web.py+nginx</td><td>211</td>
        <td><div style='background: #0de; width: 19px'></div></td>
    </tr>
</table>

<p><em>Web.py+nginx</em> has worked with <em>flup</em> <em>FastCGI</em>
options: <em>multiplexed=False</em>, <em>multithreaded=False</em>.
If <em>multiplexed=True</em> it has worked slightly slower.
If <em>multithreaded=True</em> and there was only one process running the
<em>nginx</em> server has reported following errors:<p>

<pre>[error] 18166#0: *66139 connect() to
unix:/home/michal/Programowanie/web_bench/socket failed (11: Resource
temporarily unavailable) while connecting to upstream</pre>

<p>Multiple <em>FastCGI</em> processes were spawned using
<a href='http://redmine.lighttpd.net/projects/spawn-fcgi/wiki'>spawn-fcgi</a>.

<h3>Conclusion</h3>

<p>As you can see Go wins in almost all test cases. Worse results of
<em>web.go</em> framework is probably due to the fact that it try find static
file for given URL before run a handler function. It surprised me the very high
performance of <em>tornado</em> Python framework, especially in relation to
<em>web.py</em> framework. I was also surprised, that <em>CherryPy</em> server
is faster than <em>nginx</em>+<em>flup</em> (I use
<em>web.py</em>+<em>flup</em>+<em>nginx</em> for almost all my Python Web
applications).</p> 

</body>
</html>
