<!DOCTYPE HTML PUBLIC '-//W3C//DTD HTML 4.01 Transitional//EN'>
<html>
<head>
<title>Benchmarking Go and Python Web servers</title>
<meta http-equiv='Content-type' content='text/html; charset=utf-8'>
<style type='text/css' media='all'>
body {
  font-family: "Bitstream Vera Sans", Verdana, sans-serif;
  font-size: 13px;
  line-height: 1.23em;
  padding: 0;
  margin: 1.23em;
  background: white;
  color: black;
}
em {
  font-style: italic;
  color: #034;
}
a {
  color: #04a;
  text-decoration: none;
  font-style: italic;
}
a:hover {
  color: #a40;
  text-decoration: underline;
}
a:active {
  color: #c00;
}
code, pre {
  font-size: 13px; 
}
pre {
  background: #F0F0F0;
  padding: 0.5em 2em;
}
table {
  background: #fff;
  border-collapse: collapse;
  margin: 2px;
  font-family: sans-serif;
  font-size: 12px;
}
th {
    background:	#a64;
    color: #fff;
    padding: 2px;
    border: 1px solid #ba9;
}
td {
    text-align: center;
    padding: 2px;
    border: 1px solid #ba9;
}
td:last-child {
    text-align: left;
}
td div {
    height: 10px;
}
</style>
</head>
<body>
<h2>Benchmarking Go and Python Web servers</h2>

<p>To build the Web applications I use mostly
<a href='http://www.python.org/'>Python</a>. An year ago I started
learning <a href='http://golang.org/'>Go</a>, mainly for fun. In the meantime it
turned out that I have to rewrite some old CGI application written in C, which
have worked with <a href='http://www.acme.com/software/thttpd/'>thttpd</a>
server in <a href='http://en.wikipedia.org/wiki/Chroot'>chroot</a> mode. I
started searching for a tool with which I could write a standalone web
application with embedded web server, easy to chroot. At the same time I started
play with <a href='http://www.getwebgo.com'>web.go</a> framework,
<a href='https://github.com/hoisie/mustache.go'>mustache.go</a>
templates, Go native <a href='http://golang.org/pkg/http/'>http</a> package and
<a href='https://github.com/Philio/GoMySQL'>GoMySQL</a> database API. I found
that the Go with <em>http</em>, <em>mustache.go</em> and <em>GoMySQL</em>
packages would be an ideal tools to do my job. So I decided to try write my
application in Go.</p>

<p>During work it appeared that I need something more flexible than
<em>mustache.go</em> and something more mature and bug-free than
<em>GoMySQL</em>. Finally, I wrote my application using
<a href='https://github.com/ziutek/kasia.go'>Kasia.go</a> templates and 
<a href='https://github.com/ziutek/mymysql'>MyMySQL</a> (I wrote these packages
specifically for my application but decided to make it available for Go
community). Rewritten application works very well even under much greater load
than the previous one. I began to wonder about how faster (or maybe slower) is
Go than Python for implementing standalone Web applications. I decided to do
several tests, taking into account the use of different frameworks and servers.
For comparison, I picked up following Go packages:</p>

<ul>
    <li>raw Go <em>http</em> package,</li>
    <li><em>web.go</em> framework (it uses <em>http</em> package to run in
    standalone mode),</li>
    <li><a href='http://garyburd.github.com/twister/'>twister</a> framework (it
    also uses <em>http</em> package),
</ul>

<p>and following Python Web servers/frameworks:</p>

<ul>
    <li><a href='http://webpy.org/'>web.py</a> framework with
    <a href='http://www.cherrypy.org'>CherryPy</a> WSGI server,</li>
    <li><a href='http://www.tornadoweb.org/'>tornado</a> asynchronous
    server/framework.</li>
</ul>

<p>For each case I wrote a simple application, slightly more complicated that
typical <em>Hello World</em> example. Any application consist of:</p>

<ul>
    <li>parsing parameters in URL path using regular expressions,</li>
    <li>using <em>for</em> statement to create multiple line output,</li>
    <li>using <em>printf</em>-like formatting function/expression to format
    output.<li>
</ul>

<p>I think that these operations are common in any Web application, so should be
included in any simple benchmark test. Below I put links to the source code for
all test applications:</p>

<ul>
<li>
<a href='https://github.com/ziutek/web_bench/blob/master/http.go'>Go http</a>
</li>
<li>
<a href='https://github.com/ziutek/web_bench/blob/master/webgo.go'>web.go</a>
</li>
<li>
<a href='https://github.com/ziutek/web_bench/blob/master/twister.go'>twister</a>
</li>
<li>
<a href='https://github.com/ziutek/web_bench/blob/master/webpy.py'>web.py</a>
</li>
<li>
<a href='https://github.com/ziutek/web_bench/blob/master/trnado.py'>tornado</a>
</li>
</ul>

<h3>Testing environment</h3>

<p>The test environment consisted of two PCs (traffic generator and application
server) connected using direct GigabitEthernet link.</p>

<ul>
    <li><em>Generator</em>: 2 x Xeon 2.6 GHz with hyperthreading, Debian SID,
    kernel: 2.6.33.7.2-rt30-1-686 #1 SMP PREEMPT RT;</li>
    <li><em>Server</em>: MSI Netbook with two core Intel U4100 1.30GHz, AC power
    connected, 64-bit Ubuntu 10.10, kernel: 2.6.35-25-generic #44-Ubuntu SMP;
    </li>
</ul>

<p>To generate HTTP traffic and measure the performance of any test application
I used <a href='http://www.joedog.org/index/siege-home'>siege</a>
benchmarking utility. Siege can simulate multiple users using multiple threads.
I use the following command to generate traffic <em>siege</em>:</p>

<pre>siege -c 200 -t 20s http://SERVER_ADDR:8080/Hello/100</pre>

<p>It simulates traffic generated by 200 users and works for 20s. With given URL
Web application produces 100 lines output for any request. Go applications was
compiled using Go release.2011-02-01.1</p>

<h3>Results</h3>

<p>GOMAXPROCS=1, one Python process:<p>

<table>
    <tr><th>Framework</th><th colspan='2'>Transaction rate [1/sec]</th></tr>
    <tr>
        <td>Go http</td><td>1350</td>
        <td><div style='background: #0b0; width: 135px'></div></td>
    </tr>
    <tr>
        <td>Twister</td><td>1324</td>
        <td><div style='background: #d00; width: 132px'></div></td>
    </tr>
    <tr>
        <td>Web.go</td><td>1141</td>
        <td><div style='background: #00e; width: 114px'></div></td>
    </tr>
    <tr>
        <td>Tornado</td><td>882</td>
        <td><div style='background: #ed0; width: 88px'></div></td>
    </tr>
    <tr>
        <td>Web.py</td><td>169</td>
        <td><div style='background: #0dd; width: 17px'></div></td>
    </tr>
</table>

<p>GOMAXPROCS=2, two Python processes working simultaneously:</p>

<table>
    <tr><th>Framework</th><th colspan='2'>Transaction rate [1/sec]</th></tr>
    <tr>
        <td>Go http</td><td>1768</td>
        <td><div style='background: #0b0; width: 177px'></div></td>
    </tr>
    <tr>
        <td>Twister</td><td>1746</td>
        <td><div style='background: #d00; width: 175px'></div></td>
    </tr>
    <tr>
        <td>Tornado</td><td>1682</td>
        <td><div style='background: #ed0; width: 168px'></div></td>
    </tr>
    <tr>
        <td>Web.go</td><td>1516</td>
        <td><div style='background: #00e; width: 152px'></div></td>
    </tr>
    <tr>
        <td>Web.py</td><td>308</td>
        <td><div style='background: #0dd; width: 31px'></div></td>
    </tr>
</table>

<p>GOMAXPROCS=4, four Python processes working simultaneously:</p>

<table>
    <tr><th>Framework</th><th colspan='2'>Transaction rate [1/sec]</th></tr>
    <tr>
        <td>Go http</td><td>2063</td>
        <td><div style='background: #0b0; width: 206px'></div></td>
    </tr>
    <tr>
        <td>Twister</td><td>2020</td>
        <td><div style='background: #d00; width: 202px'></div></td>
    </tr>
    <tr>
        <td>Web.go</td><td>1753</td>
        <td><div style='background: #00e; width: 175px'></div></td>
    </tr>
    <tr>
        <td>Tornado</td><td>1662</td>
        <td><div style='background: #ed0; width: 166px'></div></td>
    </tr>
    <tr>
        <td>Web.py</td><td>304</td>
        <td><div style='background: #0dd; width: 30px'></div></td>
    </tr>
</table>

<h3>Conclusion</h3>

<p>As you can see Go implementations of Web application wins in almost all test
cases. Worse results of <em>web.go</em> framework is probably due to the fact
that it try find static file for given URL before run a handler function. It
surprised me the very high performance of <em>tornado</em> Python framework,
especially in relation to <em>web.py</em> framework running on to of
<em>CherryPy</em> server (I use <em>web.py</em> for almost all my Python Web
applications).</p> 
<p>You can see how good job gorutines do. Probably, there is no reason to write
<a href='http://en.wikipedia.org/wiki/Epoll'>epoll</a> based asynchronous Web
server in Go (but it would be interesting to prove this thesis).</p>

</body>
</html>
